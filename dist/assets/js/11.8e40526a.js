(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{420:function(e,n,t){"use strict";t.r(n);var r=t(2),o=Object(r.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("通过"),n("code",[e._v("ip addr")]),e._v("命令可以看到，这里有三个网卡，")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("lo： 本机回环地址")])]),e._v(" "),n("li",[n("p",[e._v("etho ： 默认网卡")])]),e._v(" "),n("li",[n("p",[e._v("docker0 ：docker的网卡")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("[root@VM_0_5_centos dockerFile]# ip addr\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000\n    link/ether 52:54:00:6f:cb:a8 brd ff:ff:ff:ff:ff:ff\n    inet 172.27.0.5/20 brd 172.27.15.255 scope global eth0\n       valid_lft forever preferred_lft forever\n3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN \n    link/ether 02:42:27:d8:f7:98 brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\n       valid_lft forever preferred_lft forever\n")])])]),n("p",[e._v("docker网络原理\nveth-pair技术\n顾名思义，veth-pair 就是一对的虚拟设备接口，和 tap/tun 设备不同的是，它都是成对出现的。一端连着协议栈，一端彼此相连")]),e._v(" "),n("p",[e._v("我们每启动一个docker容器，docker就会给docker容器分配一个ip，并会生成一对（2个）网卡，因为我们在安装docker容器时就会安装一个docker专用的网卡；所以启动后，不但容器里面会有一个网卡，宿主机也有有一个网卡用来专门绑定容器用的；所以它们的网卡是一对一对出现的， 这就是veth-pair技术；\n"),n("img",{attrs:{src:"https://img-blog.csdnimg.cn/111c564a45614103bc7d4451a0ff7061.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAamF2YeWPtuaWsOS4nOiAgeW4iA==,size_13,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("# 查看本机docker所有网络\ndocker network ls\n\n# 创建网络  --driver 是网络模式，--subnet是子网掩码，后面的/16表示可以生成6万多个ip， --gateway是网关地址\ndocker network create 网络名称 --driver bridge --subnet 192.168.0.1/16 --gateway 192.168.0.2 mynet\n\n# 将容器加入到当前网络\ndocker network connect 网络名称 容器名称\n\n# 断开容器的网络 （容器必须是运行状态才能断开连接）\ndocker network disconnect 网络名称 容器名称\n\n# 查看网络的详细信息\ndocker network inspect 网络id/网络名称\n\n#删除网络\ndocker network rm 网络id/网络名称\n\n# 删除所有未使用的网络\ndocker network prune --f\n\n")])])]),n("p",[e._v("查看所有的docker网络")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("[root@VM_0_5_centos ~]# docker network ls\nNETWORK ID     NAME      DRIVER    SCOPE\nf77512c426f3   bridge    bridge    local\n7a19c378ddd5   host      host      local\n62ad5c8176f0   none      null      local\n\n说明\n\n  NETWORK ID 网络id\n  NAME 网络名称 \n  DRIVER 网络模式\n  SCOPE 作用域\n")])])]),n("p",[n("strong",[e._v("网络模式分类")])]),e._v(" "),n("ul",[n("li",[e._v("bridge ： 桥接（默认），B和C通过A来连接，A就是路由")]),e._v(" "),n("li",[e._v("none： 不配置网络")]),e._v(" "),n("li",[e._v("host： 主机模式，和宿主机共享网络；")]),e._v(" "),n("li",[e._v("container： 容器网络联通（用的少，局限性大）")])]),e._v(" "),n("h1",{attrs:{id:""}},[n("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")])])])}),[],!1,null,null,null);n.default=o.exports}}]);